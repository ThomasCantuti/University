\section{Terminazione, Correttezza, Complessità}
Come si analizza un algoritmo e come di studia la sua complessità
distinzione tra iterazione e ricorsione
notazione asintotica

\subsection{Analizzare gli algoritmi}
4 caratteristiche principali di un algoritmo:
\begin{itemize}
\item \textbf{correttezza}: l'algoritmo restituisce sempre la risposta corretta
\item \textbf{completezza}: ogni risposta corretta è restituita dall'algoritmo
\item \textbf{terminazione}: l'algoritmo termina sempre (non entra in loop infiniti)
\item \textbf{complessità}: l'algoritmo termina in un tempo ragionevole
\end{itemize}

\subsection{Caso iterativo}
\subsubsection{Analisi algoritmica}
Esempio: InsertionSort
\begin{verbatim}
proc InsertionSort (A) {
    for (j = 2 to A.length) {
        key = A[j]
        i = j - 1
        while ((i > 0) and (A[i] > key)) {
            A[i + 1] = A[i]
            i = i - 1
        }
        A[i + 1] = key
    }
}
\end{verbatim}
- \textbf{terminazione} -> ciclo for termina quando j < A.length e ciclo while termina quando i <= 0 e A[i] <= key -> terminazione garantita da ciclo esterno e interno
- \textbf{correttezza} -> stabilire una proprietà del ciclo principale che sia vera prima, durante e dopo l'esecuzione del ciclo -> tecnica dell'invariante con A[1, ..., j-1] sempre ordinato
- \textbf{complessità}:
\begin{verbatim}
proc InsertionSort (A) {
    for (j = 2 to A.length) { --> n * c1
        key = A[j] --> (n-1) * c2
        i = j - 1 --> (n-1) * c3
        while ((i > 0) and (A[i] > key)) { --> c4 * Σ_{j=2}^{n} (t_j)
            A[i + 1] = A[i] --> c5 * Σ_{j=2}^{n} (t_j - 1)
            i = i - 1 --> c6 * Σ_{j=2}^{n} (t_j - 1)
        }
        A[i + 1] = key --> (n-1) * c7
    }
}
\end{verbatim}
- c1, c2, c3, c4, c5, c6, c7 sono costanti
- n è la dimensione dell'input
- t_j è il tempo di esecuzione del ciclo while al passo j (va da 2 ad n, nel caso migliore t_j = 1 ovvero input già ordinato, nel caso peggiore t_j = j ovvero input ordinato al contrario)

- \textbf{caso migliore}:
\[T(n) = C + c4 * (n - 1)\]
\[C = c1 * n + c2 * (n-1) + c3 * (n-1) c7 * (n-1)\]
risulta una funzione lineare (con a,b costanti):
\[T(n) = a * n + b\]

- \textbf{caso peggiore}: 
\[T(n) = C + c4 * ( (n * (n + 1) / 2) - 1) + c5 * ( (n * (n - 1) / 2) ) + c6 * ( (n * (n - 1) / 2) )\]
risulta una funzione quadratica (con a,b,c costanti):
\[T(n) = a * n^2 + b * n + c\]

\subsection{Caso ricorsivo}
\subsubsection{Analisi algoritmica}
Esempio: RecursiveBinarySearch
\begin{verbatim}
proc RecursiveBinarySearch (A, low, high, k) {
    if (low > high)
        then return nil
    mid = (high + low)/2
    if (A[mid] = k)
        then return mid
    if (A[mid] < k)
        then return RecursiveBinarySearch(A, mid + 1, high, k)
    if (A[mid] > k)
        then return RecursiveBinarySearch(A, low, mid - 1, k)
}
\end{verbatim}
